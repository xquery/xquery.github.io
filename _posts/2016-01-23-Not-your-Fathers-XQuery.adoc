= Not your Father's XQuery

Last year, I embarrassed myself by losing patience with someone who I believed was blindly slagging off XSLT. 

What the unnamed individual did not realise was that they were talking about an ancient version of https://www.w3.org/TR/xslt[XSLT]. We can partially blame browser built in support of v1.0 (almost to the point where I think we should lobby for XSLT 1.0 removal from all browsers!). Even with the existance of the excellent http://www.saxonica.com/ce/index.xml[SAXON-CE XSLT v2.0] implementation for the browser, its hard to get folks to take another look at XSLT in browser context (that won't stop me from using it!). If javascript v1.0 was still used in the browser I doubt it would enjoy the broad acceptance it has today.

I've not been as charitable with younger programmers as older programmers were with me when I was first learning the trade. The rate of change in our industry is ridiculous and expecting newcomers to have all the context about any particular programming language is quite impossible. Clearly the onus is upon those with 'context' to communicate what a programming language is today.

XQuery is experiencing a similar scenario where developers form an initial opinion of XQuery based on v1.0 of the language. 

To feel like you are travelling back in time (or to another universe) just take a look at how xquery gets used in any of http://www.oracle.com/technetwork/database-features/xmldb/index-087544.html[Oracle] or http://beyondrelational.com/modules/2/blogs/28/posts/10279/xquery-labs-a-collection-of-xquery-sample-scripts.aspx[Microsoft's] database offerings. When I look at XQuery examples in those environments my eyes get blurry and I feel light headed.

Anyone using XQuery in those environments would conclude XQuery is:

* only for querying XML
* an unweildy addon to much simpler SQL
* hardly a programming language


== XQuery 1.0 (circa 2010)

https://www.w3.org/TR/xquery/


== XQuery 3.0 (circa )

https://www.w3.org/TR/xquery-30/

=== Ease of use

Some of the new features like:

* try/catch 
* string concat with ||
* mapping operator ! for simple for expressions
* count clause in FLWOR Expressions
* Switch expressions
* Computed namespace constructors
* Output declarations

are aimed at making the language easier formalising many common extensions found in the wild.

=== Selection

group by clause in FLWOR Expressions (3.10.7 Group By Clause).
tumbling window and sliding window in FLWOR Expressions (3.10.4 Window Clause).

=== Functions, functions, functions

let $sq :=
 function($i as xs:integer) as xs:integer {
 $i * $i
 }
Inline functions are expressions and can
appear anywhere an expression is allowed.

Function literals:
– fn:abs#1, fn:max#2, my:func#3
● Partial application (currying):
– string-join(?, ', ')
– contains(?, ?, 'http://collation/case-blind')
● Run-time discovery:
– function-lookup($name, $arity)

Functions that take functions
as an argument
● fn:filter($function, $sequence)
● fn:map($function, $sequence)
● fn:map-pairs($function, $seq1, $seq2)
● fn:fold-left($function, $initial, $sequence)
● fn:fold-right($function, $initial, $sequence)

Properties of functions
● function-name($function)
● function-arity($function)

Use cases for higher-order
functions
● Dynamic despatch mechanism
– alternative to XSLT template rules
– substitute for polymorphism
● Overcome limitations of XDM type system
● Reusable algorithms such as detection of
cycles in a graph
● Reduce the need to write simple things
using recursion


=== Annotations

=== The Rest

Other new functions
* trig/math functions: sin(), cos(), sqrt() etc
* analyze-string()
* format-date(), format-number(), generateid(),
unparsed-text() etc
– moved from XSLT to common library
* head(), tail(), path()
* environment-variable(), uri-collection()
* parse(), serialize()
* Function assertions in function tests.




== XQuery 3.1 (circa 2016)

https://www.w3.org/TR/xquery-31/

maps are being proposed to be added to the language

