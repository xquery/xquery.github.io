= Not your Father's XQuery

Last year, I embarressed myself by losing patience with someone who I believed was blindly slagging off XSLT. What the individual did not realise was that they were talking about an ancient version of XSLT ... though how the notion got embedded in that form when he was playing with toy guns ? We can partially blame browser support for that (almost to the point where I think we should lobby for XSLT 1.0 removal from browsers!). If javascript v1.0 was still used in the browser I doubt it would enjoy the broad usage it has today. 

Then I came to another conclusion that I've not been so charitable with younger programmers ... not nearly as charitable as older programmers were with me when I was first learning the trade. The rate of change in our industry is ridiculous and expecting newcomers to have all the context in 'RAM' is quite impossible.

I can see a similar situation with XQuery emerging where developers initial contact with the language may have been with XQuery v1.0 and shorn of any context think of it as a limited language meant only for querying XML. You only need to read current posts of how to use XQuery in database offerings from Oracle of Microsoft to travel back in time.


== XQuery 1.0 (circa 1999)

https://www.w3.org/TR/xquery/


== XQuery 3.0 (circa )

https://www.w3.org/TR/xquery-30/

=== Ease of use

Some of the new features like:

* try/catch 
* string concat with ||
* mapping operator ! for simple for expressions
* count clause in FLWOR Expressions
* Switch expressions
* Computed namespace constructors
* Output declarations

are aimed at making the language easier formalising many common extensions found in the wild.

=== Selection

group by clause in FLWOR Expressions (3.10.7 Group By Clause).
tumbling window and sliding window in FLWOR Expressions (3.10.4 Window Clause).

=== Functions, functions, functions

let $sq :=
 function($i as xs:integer) as xs:integer {
 $i * $i
 }
Inline functions are expressions and can
appear anywhere an expression is allowed.

Function literals:
– fn:abs#1, fn:max#2, my:func#3
● Partial application (currying):
– string-join(?, ', ')
– contains(?, ?, 'http://collation/case-blind')
● Run-time discovery:
– function-lookup($name, $arity)

Functions that take functions
as an argument
● fn:filter($function, $sequence)
● fn:map($function, $sequence)
● fn:map-pairs($function, $seq1, $seq2)
● fn:fold-left($function, $initial, $sequence)
● fn:fold-right($function, $initial, $sequence)

Properties of functions
● function-name($function)
● function-arity($function)

Use cases for higher-order
functions
● Dynamic despatch mechanism
– alternative to XSLT template rules
– substitute for polymorphism
● Overcome limitations of XDM type system
● Reusable algorithms such as detection of
cycles in a graph
● Reduce the need to write simple things
using recursion


=== Annotations

=== The Rest

Other new functions
* trig/math functions: sin(), cos(), sqrt() etc
* analyze-string()
* format-date(), format-number(), generateid(),
unparsed-text() etc
– moved from XSLT to common library
* head(), tail(), path()
* environment-variable(), uri-collection()
* parse(), serialize()
* Function assertions in function tests.




== XQuery 3.1 (circa 2016)

https://www.w3.org/TR/xquery-31/

maps are being proposed to be added to the language

